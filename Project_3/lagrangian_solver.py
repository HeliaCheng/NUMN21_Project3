#Lagrangian solver in 2d, for rectangular geometry.
#The boundary condition can be set on each side.
#Only Dirichlet is set for now

import numpy as np
import matplotlib.pyplot as plt
from matplotlib.patches import Rectangle
from scipy.sparse import csr_array
from scipy.sparse.linalg import spsolve

def create_lagrangian_matrix(boundary,h):
    """
    boundary is a dictionary with all boundaries
    

    Does support Neumann condtion, but need to be tested further.
     
    Can be changed if necessary.
    

    """
    
    left, left_cdt = boundary["left"]
    right, right_cdt = boundary["right"]
    bottom, bottom_cdt = boundary["bottom"]
    top, top_cdt = boundary["top"]

    
    assert np.shape(left) == np.shape(right)
    assert np.shape(top) == np.shape(bottom)
    n = len(left)
    m = len(bottom)
    nm = n*m
    rows = []
    cols = []
    values = []
    def add_to_lists(row,col,value):
        """Add the value of the matrix at the specified row and column"""
        rows.append(row)
        cols.append(col)
        values.append(value)
    #print(A.shape)
    #We work from row to row, column to column
    #First, interior points
    for row in range(n):
        for col in range(m):
            
          center = row*m + col
          add_to_lists(center,center,-4)
          #Try to fill every point, if we are not out of bound
          if(col != m-1):#Point to the right
            add_to_lists(center,center+1,1)
          elif(right_cdt.lower() == "neumann"):
              add_to_lists(center,center,1)
          if(col != 0):#Point to the left
            add_to_lists(center,center-1,1)
          elif(left_cdt.lower() == "neumann"):
              add_to_lists(center,center,1)
          if(row != n-1): #Point below
            add_to_lists(center,center+m,1)
          elif(bottom_cdt.lower() == "neumann"):
              add_to_lists(center,center,1)
          if(row != 0): #Point above
            add_to_lists(center,center-m,1)
          elif(top_cdt.lower() == "neumann"):
              add_to_lists(center,center,1)
    return csr_array((values,(rows,cols)),shape=(nm,nm))/h**2





def create_lagrangian_rhs(boundary,h):
    """ 
    Create the right hand side in the Lagrangian problem with the given boundary conditions.
    
    Arguments:
        - boundary (dict): A dictionary made up of each boundary, and the associated vector. Each side should have a unique boundary condition
        - h (float): The spacial distance between two adjacent points.
        
    For the moment, this does not support having a second distance between each point.
    
    The dictionary should have the key to represent the sides "left", "right", "top" or "bottom", with values being a list where the first element
    being the boundary vector, and the second element being the type of boundary condition as a string, "neumann" or "dirichlet"
    
    For Neumann boundary condition, the expected derivative is in the x or y direction, for the "left"/"right" side and the "top", "bottom" sides respectively.
    
    Returns:
    
    The right hand side vector of the Linear system to solve, where the matrix is generated by the create_lagrangian_matrix() function.
    
    """
    left, left_cdt = boundary["left"]
    right, right_cdt = boundary["right"]
    top , top_cdt = boundary["top"]
    bottom , bottom_cdt = boundary["bottom"]
    n = np.shape(left)[0]
    m = np.shape(top)[0]
    mn = m*n
    assert n == np.shape(right)[0]
    assert m == np.shape(bottom)[0]
    
    b_matrix = np.zeros((n,m))
    
    #Rule one of programming is to repeat yourself.
    if(top_cdt.lower() == "neumann"):
        b_matrix[0,:] -= top / h
    elif(top_cdt.lower() == "dirichlet"):
        b_matrix[0,:] -= top / h**2
    else: 
        raise ValueError("Unknown boundary condition")
    
    if(bottom_cdt.lower() == "neumann"):
        b_matrix[n-1,:] += bottom / h
    elif(bottom_cdt.lower() == "dirichlet"):
        b_matrix[n-1,:] -= bottom / h**2
    else: 
        raise ValueError("Unknown boundary condition")
      
    if(left_cdt.lower() == "neumann"):
        b_matrix[:,0] += left / h
    elif(left_cdt.lower() == "dirichlet"):
        b_matrix[:,0] -= left / h**2
    else: 
        raise ValueError("Unknown boundary condition")
    
    if(right_cdt.lower() == "neumann"):
        b_matrix[:,m-1] -= right / h
    elif(right_cdt.lower() == "dirichlet"):
        b_matrix[:,m-1] -= right / h**2
    else: 
        raise ValueError("Unknown boundary condition")
    
    return b_matrix.flatten()



def visualize_stencil(A,i,j,n,m, h=1):
    """Visualize the stencil used, 

    Args:
        A (_type_): Matrix to visualize, in a csr format
        m (_type_): length of the left/right border
        n (_type_): length of the top/bottom border
        i (_type_): row to visualize
        j (_type_): column to visualize
    """
    A = A.toarray()
    A_row = A[i * n + j,:]
    stencil = A_row.reshape((n,m)) * h**2
    fig, ax = plt.subplots()
    img = ax.imshow(stencil)
    fig.colorbar(img)
    plt.show()
    

def solve_lagrangian(A,b,n,m):
    v =  spsolve(A,b)
    return v.reshape((n,m))






class Apartment3a:
    def __init__(self, delta_x=1/20, initial_temp=20, D=0.1, rooms = 3, H = 40, WF = 5, NW = 15):
        self.delta_x = delta_x
        self.D = D
        self.initial_temp = initial_temp
        self.omega = 0.8
        self.rooms = rooms
        self.n = int(1 / delta_x)  # Grid points per unit length
        self.u1 = np.ones((self.n, self.n)) * self.initial_temp  # Room 1
        self.u2 = np.ones((2 * self.n, self.n)) * self.initial_temp  # Room 2
        self.u3 = np.ones((self.n, self.n)) * self.initial_temp  # Room 3
        
        self.H = H  # Heated boundary
        self.WF = WF  # Window (cold boundary)
        self.NW = NW  # Normal wall
        #Walls room 1:
        self.north_wall_1 = np.ones(int(1/delta_x)) * self.NW
        self.east_wall_1 = np.ones(int(1/delta_x)) * self.NW  #Should depend on room 2
        self.south_wall_1 = np.ones(int(1/delta_x)) * self.NW
        self.west_wall_1 = np.ones(int(1/delta_x)) * self.H
        #Walls room 2:
        self.north_wall_2 = np.ones(int(1/delta_x)) * self.H
        self.east_wall_2 = np.ones(int(2/delta_x)) * self.NW #Should partially depend on room 3
        self.south_wall_2 = np.ones(int(1/delta_x)) * self.WF
        self.west_wall_2 = np.ones(int(2/delta_x)) * self.NW #Should partially depend on room 1
        #Walls room 3:
        self.north_wall_3 = np.ones(int(1/delta_x)) * self.NW
        self.east_wall_3 = np.ones(int(1/delta_x)) * self.H
        self.south_wall_3 = np.ones(int(1/delta_x)) * self.NW
        self.west_wall_3 = np.ones(int(1/delta_x)) * self.NW  #Should depend on room 2
        if self.rooms == 4:
            self.u4 = np.ones((int(self.n/2), int(self.n/2))) * self.initial_temp
            self.north_wall_4 = np.ones(int(0.5/delta_x)) * self.NW #Should depend on room 3
            self.east_wall_4 = np.ones(int(0.5/delta_x)) * self.NW
            self.south_wall_4 = np.ones(int(0.5/delta_x)) * self.H
            self.west_wall_4 = np.ones(int(0.5/delta_x)) * self.NW  #Should depend on room 2
        self.boundaries()
        self.init_A()

        
    def boundaries(self,room_number="all"):
        """Create the boundary dictionary for the chosen room, or all room if "all" is passed as argument by default.

        Args:
            room_number (int or str, optional): Which room to update the boundary for. Defaults to "all".
        """
        if(room_number == 1 or room_number=="all"):
            self.boundary1 = {
                "left": (self.west_wall_1, "dirichlet"),
                "right": (self.east_wall_1, "neumann"),
                "bottom": (self.south_wall_1, "dirichlet"),
                "top": (self.north_wall_1, "dirichlet")
            }
        if(room_number == 2 or room_number=="all"):
            self.boundary2 = {
                "left": (self.west_wall_2, "dirichlet"),
                "right": (self.east_wall_2, "dirichlet"),
                "bottom": (self.south_wall_2, "dirichlet"),
                "top": (self.north_wall_2, "dirichlet")
            }
        if(room_number == 3 or room_number=="all"):
            self.boundary3 = {
                "left": (self.west_wall_3, "neumann"),
                "right": (self.east_wall_3, "dirichlet"),
                "bottom": (self.south_wall_3, "dirichlet"),
                "top": (self.north_wall_3, "dirichlet")
            }
        if(room_number == 4 or room_number=="all"):
            if self.rooms == 4:
                self.boundary4 = {
                    "left": (self.west_wall_4, "neumann"),
                    "right": (self.east_wall_4, "dirichlet"),
                    "bottom": (self.south_wall_4, "dirichlet"),
                    "top": (self.north_wall_4, "neumann")
                }

    def init_A(self):
        """Initialize the matrices 
        """
        self.A1 = create_lagrangian_matrix(self.boundary1, self.delta_x)
        self.A2 = create_lagrangian_matrix(self.boundary2, self.delta_x)
        self.A3 = create_lagrangian_matrix(self.boundary3, self.delta_x)
        if self.rooms == 4:
            self.A4 = create_lagrangian_matrix(self.boundary4, self.delta_x)

    def update_b(self, room_number):
        """Update the right hand side for the system to solve for. 

        Args:
            room_number (int): Which room to create the right hand side for.
        """
        if(room_number==1):
            self.b1 = create_lagrangian_rhs(self.boundary1, self.delta_x)
        elif(room_number==2):
            self.b2 = create_lagrangian_rhs(self.boundary2, self.delta_x)
        elif(room_number==3):
            self.b3 = create_lagrangian_rhs(self.boundary3, self.delta_x)
        elif(room_number==4):
            self.b4 = create_lagrangian_rhs(self.boundary4, self.delta_x)

    def update_boundary_b(self,room_number):
        self.update_b(room_number)
        self.boundaries(room_number)

    def step(self):
        # Update boundary walls, for Dirichlet
        self.west_wall_2[self.n:] = self.u1[:,-1] #Dir, Wall of room 2 that connects to room 1
        self.east_wall_2[:self.n] = self.u3[:,0] #Dir, Wall of room 2 that connects to room 3
        if self.rooms == 4: #Dir
            self.south_wall_3[:int(self.n*0.5)] = self.u4[0,:] #Wall of room 3 that connects to room 4
            self.east_wall_2[self.n:int(self.n*1.5)] = self.u4[:,0]
        
        self.update_boundary_b(room_number=2)
        #Solve the room with Dirichlet conditions first, then send the Neumann cdt to the other ones.
        # Room 2 - the big one
        un2 = solve_lagrangian(self.A2, self.b2, 2*self.n, self.n)

        #Compute Neumann BC, send to the left and right rooms
        self.east_wall_1 = -(self.u2[self.n:,0]-self.u2[self.n:,1])/self.delta_x
        self.west_wall_3 = (self.u2[:self.n,-1] - self.u2[:self.n,-2])/self.delta_x
        
        # Room 1 - left one
        self.update_boundary_b(room_number=1)
        un1 = solve_lagrangian(self.A1, self.b1, self.n, self.n)
        
        # Room 3 - right one
        self.update_boundary_b(room_number=3)
        un3 = solve_lagrangian(self.A3, self.b3, self.n, self.n)

        #Compute Neumann BC, send to the 4th room
        if self.rooms == 4:
            
            self.west_wall_4 = (self.u2[self.n:int(self.n*1.5), -1] - self.u2[self.n:int(self.n*1.5),-2])/self.delta_x
            self.north_wall_4 = (self.u3[-1, :int(self.n*0.5)] - self.u3[-2, :int(self.n*0.5)])/self.delta_x
            # Room 4 - small one
            
            self.update_boundary_b(room_number=4)
            
            un4 = solve_lagrangian(self.A4, self.b4, int(0.5*self.n), int(0.5*self.n))
            self.u4 = self.omega*un4 + (1-self.omega)*self.u4
        
        # Update room temperatures
        self.u1 = self.omega*un1 + (1-self.omega)*self.u1
        self.u2 = self.omega*un2 + (1-self.omega)*self.u2
        self.u3 = self.omega*un3 + (1-self.omega)*self.u3

        

    def visualize(self):
        av1 = self.u1.sum()/(self.n**2)
        av2 = self.u2.sum()/(2*self.n**2)
        av3 = self.u3.sum()/(self.n**2)
        if self.rooms == 4:
            av4 = self.u4.sum()/(0.25*self.n**2)
            av_ap = (av1 + 2*av2 + av3 + av4*0.25)/4.25
        else:
            av_ap = (av1 + 2*av2 + av3)/4
        print('Average room 1:', av1)
        print('Average room 2:', av2)
        print('Average room 3:', av3)
        if self.rooms == 4:
            print('Average room 4:', av4)
        print('Average appartment:', av_ap)
        U = np.ones((2 * self.n, 3 * self.n)) * (self.u2.min() + self.u2.max()) / 2
        U[self.n:, :self.n] = self.u1
        U[:, self.n:2 * self.n] = self.u2
        U[:self.n, 2 * self.n:] = self.u3
        if self.rooms == 4:
            U[self.n:int(self.n*1.5), self.n*2:int(self.n*2.5)] = self.u4
        plt.imshow(U, cmap="twilight_shifted")
        Rec1 = Rectangle((-0.5,-0.5), self.n, self.n, color = 'white')
        ax = plt.gca()
        ax.add_patch(Rec1)
        if self.rooms == 4:
            Rec3 = Rectangle((self.n*2-0.5,self.n * 1.5-0.5), self.n*0.5, self.n*0.5, color = 'white')
            Rec4 = Rectangle((self.n*2.5-0.5,self.n * 1-0.5), self.n*0.5, self.n, color = 'white')
            ax.add_patch(Rec3)
            ax.add_patch(Rec4)
        else:
            Rec2 = Rectangle((self.n*2-0.5,self.n-0.5), self.n, self.n, color = 'white')
            ax.add_patch(Rec2)
        
        plt.hlines(self.n-0.5, -0.5, self.n-0.5, color = 'black')
        plt.vlines(self.n-0.5, -0.5, self.n*1 - 0.5,  color = 'black')
        plt.vlines(self.n - 0.5, self.n-0.5, self.n*2 - 0.5, linestyles='--',  color = 'black')
        if self.rooms == 4:
            plt.vlines(self.n*2.5 - 0.5, self.n-0.5, self.n*1.5 - 0.5,  color = 'black')
            plt.hlines(self.n*1.5-0.5, self.n*2-0.5, self.n*2.5-0.5, color = 'black')
            plt.vlines(self.n*2 - 0.5, -0.5, self.n*1.5 - 0.5, linestyles='--', color = 'black')
            plt.vlines(self.n*2 - 0.5, self.n*1.5- 0.8, self.n*2 - 0.5,  color = 'black')
            plt.hlines(self.n-0.5, self.n*2.5-0.5, self.n*3-0.5, color = 'black')
            plt.hlines(self.n-0.5, self.n*2-0.5, self.n*2.5, linestyles='--', color = 'black')
        else:
            plt.vlines(self.n*2 - 0.5, -0.5, self.n*1 - 0.5, linestyles='--', color = 'black')
            plt.vlines(self.n*2 - 0.5, self.n-0.5, self.n*2 - 0.5,  color = 'black')
            plt.hlines(self.n-0.5, self.n*2-0.5, self.n*3-0.5, color = 'black')
            
        plt.colorbar()
        plt.show()
        




if __name__ == "__main__":

    # n = 5
    # m = 6
    # left = np.ones(n) * 10
    # right = np.ones(n) * 1

    # top = np.ones(m) * 5
    # bottom = np.ones(m) * 5

    # h = 0.5



    # boundary = {"left": [left,"neumann"],
    #             "right": [right,"dirichlet"],
    #             "top": [top,"dirichlet"],
    #             "bottom": [bottom,"dirichlet"]}


    # A =  create_lagrangian_matrix(boundary,h)
    # b = create_lagrangian_rhs(boundary,h)
    # print(A.toarray())


    # v = solve_lagrangian(A,b,n,m)
    
    #plt.imshow(v)
    #plt.show()

    # Instantiate and run
    apartment3a = Apartment3a(delta_x=1/40, D=0.2, rooms = 4, H = 30, NW = 18)
    apartment3a.omega = 0.5
    for i in range(100):
        if i%10 == 0:
            print(i)
        apartment3a.step()

    apartment3a.visualize()

    #Folkhälsomyndigheten: temperature 20-24 
